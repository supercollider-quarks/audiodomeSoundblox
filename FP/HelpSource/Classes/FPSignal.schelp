CLASS:: FPSignal
summary:: Implementation of Functional Reactive Programming.
categories:: FP, TimerES
related:: Classes/EventSource

description::

This is port of the reactive-core library for Scala into SuperCollider.

For more info see:

http://www.reactive-web.co.cc/core/Signal

note::
Right now because sc does not have weak references, this can cause a build up of EventStreams when using flatCollect.
::


instancemethods::
method::now
the current value of the Signal

method::changes
An EventSource which fires events every time the signal changes.

code::
(
x = Var(2);
x.changes;
)
::

method::do
When the Signal changes, runs f with new value.

code::
(
x = Var(0);
f = { |x| postln("look what I got:"++x) };
x.do(f);
x.value_(3)
)

//stop the action
(
x.stopDoing(f);
x.value_(4)
)
::

method::doDef

Run f every time a new event arrives and save the function using the name given

argument::name 
A key
argument::f
The function to call
returns:: Unit

code::
(
x = Var(0);
x.doDef(\hello,{ |x| postln("look what I got:"++x) });
x.value_(3)
)
(
x.doDef(\hello,{ |x| postln("And now I print it like this:"++x) });
x.value_(3)
)
(
//remove the action
x.doDef(\hello);
x.value_(3)
)
::

method::collect
argument::f
f: A => B
discussion::
code::
(
x = Var(2);
y = x.collect( _*100 );
y.do(_.postln);
)

x.value_(100)
::
method::flatCollect
argument::f
f: A => FPSignal[B]
discussion::
code::
(
x = Var(1);
y = Var(2);
z = x.flatCollect{ |x| y.collect{ |y| [x,y] } };
z.do(_.postln);
)

x.value_(5);
y.value_(6);
::

method::flatCollectR
argument::f
f: A => FPSignal[B]
discussion::
code::
//this is the correct syntax but will cause a build up of EventSources
(
x = Var(1);
y = Var(2);
z = x.flatCollect{ |x| y.collect{ |y| "Ping".postln; [x,y] } };
z.do(_.postln);
)
//run this multiple times
x.value_(3);
//you will get multiple pings, when you should have only one.
y.value_(4);

//Now with an flatCollectR
(
x = Var(1);
y = Var(2);
z = x.flatCollectR{ |x| y.collect{ |y| "Ping".postln; [x,y] } };
z.do(_.postln);
)
//run this multiple times
x.value_(3);
//only one ping.
y.value_(4);
::

method::bus

create a bus and add a function to the event stream that updates the bus.

returns:: Some( Tuple2( Bus, Function ) ). The function is returned to be able to stop updating the Bus in the future. If the server is not running returns None.

code::
x = { SinOsc.ar( \freq.kr(400) )*0.1 }.play

(
y = Var(900);
b = y.bus(s);
//b might be None if the server is not running.
b.do{ |z| x.map(\freq, z.at1) }
)

//change freq to 200
y.value_( 200 );
::

Examples::

Combine Signals using a function:

code::
(
x = Var(1.0);
y = Var(1.0);
z = Var(1.0);
w = { |x,y,z| x + y + z } <%> x <*> y <*> z; //analogous to { |x,y,z| x + y + z }.(1.0,1.0,1.0)
w.do( postln(_) );
x.value_(9.0);
y.value_(3.0);
z.value_(1.0);
)
::


The code above will cause a build up of EventStreams you should use instead <**> which internally will use flatCollectR

code::
x = Var(1.0);
y = Var(2.0);
z = Var(6.0);
w = { |x,y,z| x + y + z } <%> x <**> y <**> z;
w.do( postln(_) );
x.value_(9.0);
y.value_(3.0);
z.value_(1.0);
::
