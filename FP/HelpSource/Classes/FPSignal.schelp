CLASS:: FPSignal
summary:: Implementation of Functional Reactive Programming.
categories:: FP, TimerES
related:: Classes/EventSource

description::

This is port of the reactive-core library for Scala into SuperCollider.

For more info see:

http://www.reactive-web.co.cc/core/Signal

note::
Right now because sc does not have weak references, this can cause a build up of EventStreams when using flatCollect.
::


instancemethods::
method::now
the current value of the Signal

method::changes
An EventSource which fires events every time the signal changes.

code::
(
x = Var(2);
x.changes;
)
::

method::do
When the Signal changes, runs f with new value.

code::
(
x = Var(2);
x.do{ |x| postln("look what I got:"++x) };
x.value_(3);
)
::
method::collect
argument::f
f: A => B
discussion::
code::
(
x = Var(2);
y = x.collect( _*100 );
y.do(_.postln);
)

x.value_(100)
::
method::flatCollect
argument::f
f: A => FPSignal[B]
discussion::
code::
(
x = Var(1);
y = Var(2);
z = x.flatCollect{ |x| y.collect{ |y| [x,y] } };
z.do(_.postln);
)

x.value_(5);
y.value_(6);
::

method::flatCollectR
argument::f
f: A => FPSignal[B]
discussion::
code::
//this is the correct syntax but will cause a build up of EventSources
(
x = Var(1);
y = Var(2);
z = x.flatCollect{ |x| y.collect{ |y| "Ping".postln; [x,y] } };
z.do(_.postln);
)
//run this multiple times
x.value_(3);
//you will get multiple pings, when you should have only one.
y.value_(4);

//Now with an flatCollectR
(
x = Var(1);
y = Var(2);
z = x.flatCollectR{ |x| y.collect{ |y| "Ping".postln; [x,y] } };
z.do(_.postln);
)
//run this multiple times
x.value_(3);
//only one ping.
y.value_(4);
::