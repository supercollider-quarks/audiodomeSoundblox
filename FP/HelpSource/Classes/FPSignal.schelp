CLASS:: FPSignal
summary:: Implementation of Functional Reactive Programming.
categories:: FP, TimerES
related:: Classes/EventSource

description::

This is port of the reactive-core library for Scala into SuperCollider.

For more info see:

http://www.reactive-web.co.cc/core/Signal

CLASSMETHODS::

PRIVATE:: buildFlatCollect

METHOD:: new

not to be used directly, use instead Var or Val.

instancemethods::

PRIVATE::initFPSignal

method::now
the current value of the Signal


SUBSECTION::Perform Side-Effects

method::do
When the Signal changes, runs f with new value.

code::
(
x = Var(0);
f = { |x| postln("look what I got:"++x) };
x.do(f);
x.value_(3)
)

//stop the action
(
x.stopDoing(f);
x.value_(4)
)
::

method::doDef

Run f every time a new event arrives and save the function using the name given

argument::name 
A key
argument::f
The function to call
returns:: Unit

code::
(
x = Var(0);
x.doDef(\hello,{ |x| postln("look what I got:"++x) });
x.value_(3)
)
(
x.doDef(\hello,{ |x| postln("And now I print it like this:"++x) });
x.value_(3)
)
(
//remove the action
x.doDef(\hello);
x.value_(3)
)
::

method::stopDoing

Stop running function f.
argument::f
A function
returns:: Unit


SUBSECTION::Combinators


method::changes
An EventSource which fires events every time the signal changes.

code::
(
x = Var(2);
x.changes;
)
::

method::collect
argument::f
f: A => B
discussion::
code::
(
x = Var(2);
y = x.collect( _*100 );
y.do(_.postln);
)

x.value_(100)
::
method::flatCollect
argument::f
f: A => FPSignal[B]
discussion::
code::
(
x = Var(1);
y = Var(2);
z = x.flatCollect{ |x| y.collect{ |y| [x,y] } };
z.do(_.postln);
)

x.value_(5);
y.value_(6);
::

method::fold
Allows one, in a functional manner, to respond to an event while taking into account past events. For every event t, f is called with arguments (u, t), where u is initially the value of the 'initial' parameter, and subsequently the result of the previous application of f.
returns:: A new FPSignal that, for every event t fired by the original FPSignal, fires the result of the application of f (which will also be the next value of u passed to it). Often 'u' will be an object representing some accumulated state.
discussion::
An FPSignal that sums all the integer values fired by the parent FPSignal.
code::
(
x = Var(1.0);
y = x.fold( 0, {|state,b| state + b });
y.do(_.postln);
x.value_(1);
x.value_(4);
x.value_(7)
)
::

SUBSECTION::Disconnect from network

method::remove

Disconnects this FPSignal from the parent FPSignal (if it has a parent). If the FPSignal is not assigned to any variable anymore it will be gc'ed.

code::
(
x = Var(1.0);
y = x.collect(_+10);
y.do(postln(_));
x.value_(2);
)

(
y.remove;
x.value_(3);
//nothing is posted
)

//now the EventSource that was assigned to y can be gc'ed.
y = nil;
::

method::reset

Removes all listeners. This will disconnect this EventSource from the rest of the chain that depends on it, and the rest of the chain will be gc'ed.

code::
(
x = Var(1.0);
x.collect(_+10).do(postln(_));
x.collect(_+100).do(postln(_));
x.value_(2);
)

(
x.reset;
x.value_(3);
//nothing is posted
)
::

SUBSECTION:: Interaction with Server

method::bus

create a bus and add a function to the event stream that updates the bus.

returns:: Some( Tuple2( Bus, Function ) ). The function is returned to be able to stop updating the Bus in the future. If the server is not running returns None.

code::
x = { SinOsc.ar( \freq.kr(400) )*0.1 }.play

(
y = Var(900);
b = y.bus(s);
//b might be None if the server is not running.
b.do{ |z| x.map(\freq, z.at1) }
)

//change freq to 200
y.value_( 200 );
::


SUBSECTION:: Interaction with GUIs
You can use code::signalFromGUI:: to get an FPSignal from the GUI and the method 'connect' to connect the end of the network to an object that responds to value_

METHOD::connect

Connect this FPSignal to an object. Everytime the FPSignal fires an event the object's value_ method is called with the value.
ARGUMENT:: object
An object that responds to value_

Examples::

Combine Signals using a function:

code::
(
x = Var(1.0);
y = Var(1.0);
z = Var(1.0);
w = { |x,y,z| x + y + z } <%> x <*> y <*> z; //analogous to { |x,y,z| x + y + z }.(1.0,1.0,1.0)
w.do( postln(_) );
x.value_(9.0);
y.value_(3.0);
z.value_(1.0);
)
::

FPSignal is a Applicative Functor so we can use the apply method <*>. Applicative Functors in essence allow to "lift" a n-ary function from a domain A to a domain B, in this case it lifts functions on any type to functions on FPSignals.
We could define a lift function for each number of arguments like so:
code::
~lift2 = { |f| { |a,b| f <%> a <*> b } };
~lift3 = { |f| { |a,b,c| f <%> a <*> b <*> c } };
...
::

then the above would be equivalent to :
code::
(
x = Var(1.0);
y = Var(1.0);
z = Var(1.0);
f = { |x,y,z| x + y + z };
//we apply the lifted function on the signals.
w = ~lift3.(f).(x,y,z);
w.do( postln(_) );
x.value_(9.0);
y.value_(3.0);
z.value_(1.0);
)
::

With GUIs:

Notice that text field automatically has the correct start value.

code::
(
t = QTextField();
b = Slider().orientation_(\horizontal);
b.signalFromGUI.collect{ |x| x.linexp(0.0,1.0,300,6000) }.connect(t);
w = Window(bounds:Rect(200,200,300,50)).layout_( HLayout( b, t ) ).front;
)
::