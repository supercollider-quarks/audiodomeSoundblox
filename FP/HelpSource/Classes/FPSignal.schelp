CLASS:: FPSignal
summary:: Implementation of Functional Reactive Programming.
categories:: FP, TimerES
related:: Classes/EventSource

description::

This is port of the reactive-core library for Scala into SuperCollider.

For more info see:

http://www.reactive-web.co.cc/core/Signal

note::
Right now because sc does not have weak references, this can cause a build up of EventStreams when using flatCollect.
::


instancemethods::
method::now
the current value of the Signal

method::changes
An EventSource which fires events every time the signal changes.

code::
(
x = Var(2);
x.changes;
)
::

method::do
When the Signal changes, runs f with new value.

code::
(
x = Var(2);
x.do{ |x| postln("look what I got:"++x) };
x.value_(3);
)
::
method::collect
argument::f
f: A => B
discussion::
code::
(
x = Var(2);
y = x.collect( _*100 );
y.do(_.postln);
)

x.value_(100)
::
method::flatCollect
argument::f
f: A => FPSignal[B]
discussion::
code::
(
x = Var(1);
y = Var(2);
z = x.flatCollect{ |x| y.collect{ |y| [x,y] } };
z.do(_.postln);
)

x.value_(5);
y.value_(6);
::

method::flatCollectR
argument::f
f: A => FPSignal[B]
discussion::
code::
//this is the correct syntax but will cause a build up of EventSources
(
x = Var(1);
y = Var(2);
z = x.flatCollect{ |x| y.collect{ |y| "Ping".postln; [x,y] } };
z.do(_.postln);
)
//run this multiple times
x.value_(3);
//you will get multiple pings, when you should have only one.
y.value_(4);

//Now with an flatCollectR
(
x = Var(1);
y = Var(2);
z = x.flatCollectR{ |x| y.collect{ |y| "Ping".postln; [x,y] } };
z.do(_.postln);
)
//run this multiple times
x.value_(3);
//only one ping.
y.value_(4);
::

method::bus

create a bus and add a function to the event stream that updates the bus.

returns:: Some( Tuple2( Bus, Function ) ). The function is returned to be able to stop updating the Bus in the future. If the server is not running returns None.

code::
x = { SinOsc.ar( \freq.kr(400) )*0.1 }.play

(
y = Var(900);
b = y.bus(s);
//b might be None if the server is not running.
b.do{ |z| x.map(\freq, z.at1) }
)

//change freq to 200
y.value_( 200 );
::