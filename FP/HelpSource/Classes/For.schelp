class::For
summary::scala style For comprehensions
categories::FP

DESCRIPTION::

Implements the equivalent to scala's for comprehensions or Haskell's do notation. Unfortunatelly the proper syntax for this is not implemented, so one has to use functions instead.

Examples::

code::

//list comprehension
For([1,2,3],[4,5,6],[4,5,6],{ |x,y,t| x*y*t })
For([[1,2,3],_<2],[[4,5,6],_<5],{ |x,y| x*y })
For(
	{ [1,2,3] } <|? (_<2),
	{ [4,5,6] } <|? (_<5),
{ |x,y| x*y })

//Option
For(
	{Some(Some(30))},
	{|x| x},
{ |x| x*300 })

//Functions that return Option subclasses.
x = (\hello: (\world: 32))

//compact
For(
	x.get(\hello),
	_.get(\world),
_*100)
//verbose
For(
	x.get(\hello),
	{ |y| y.get(\world)},
{ |z| z*100})

For(
	x.get(\helo),
	_.get(\world),
_*100)

For(
	x.get(\hello),
	_.get(\wod),
_*100)


//How this would look in scala:
for(
	y<-x.get(\hello);
	z<-z.get(\world)
) yield (z *100)

//How this would look in Haskell:

singleton "hello" (singleton "world" 32)

do 	y <- Data.Map.lookup "hello" x
 	z <- Data.Map.lookup "world" y
 	return (z*100)

::