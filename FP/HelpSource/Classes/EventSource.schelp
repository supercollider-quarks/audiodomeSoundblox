CLASS:: EventSource
summary:: Implementation of Functional Reactive Programming.
categories:: FP
related:: Classes/FPSignal

description::

This is a port of the reactive-core library for Scala into SuperCollider.

For more info see:

http://www.reactive-web.co.cc/core/EventStream

note::
Right now because sc does not have weak references, this can cause a build up of EventStreams when using flatCollect. When creating new EventSources inside the flatCollect function, use instead flatCollectR.
::


An EventStream is a source of events (arbitrary values sent to listener functions). You can fire events from it, you can react to events with any behavior, and you can create derived EventStreams, whose events are based on the original EventStream.

An EventStream is like a collection in the sense that it consists of multiple values. However, unlike actual collections, the values are not available upon request; they occur whenever they occur. Nevertheless, many operations that apply to collections apply to event streams. To react to events, use foreach or foldLeft. To create derived, transformed EventStreams, use map, flatMap, filter, foldLeft, and the | (union) operator. Note that you can of course use for comprehensions as syntactic sugar for many of the above.

There are only two ways to stop an EventSource from continuing to process events:
list::
## the functional way is to use takeWhile
## the imperative way is to call .remove on the event stream.
::

subsection::Type Classes
EventSource is an instance of the Functor Type Class. It does not implement the 'pure' function therefore it is not a Monad or an Applicative Functor. It does implement the 'bind' or '>>=' function.

subsection::Templates

Templates can be defined by placing a file in a EventStreamTemplates folder in the Extensions folder. The library comes already with some templates.

note:: The names of the templates cannot be identical to method names of Object (including in additions from quarks, etc).::

Example of a template:

code::
(
func:{ |eventSource|
	eventSource.collect([Process.elapsedTime,_])
},
desc: "store time when event occured",
name: "storeWithT"
)
::

Temapletes bundled with the library:

list::

## storeWithT: store time when event occured.
code::
(
x = EventSource();
x.storeWithT.dopost;
x.fire(2)
)
::

## storePrevious: store current and previous event in an array. The initial values are assumed to be 0.0.
code::
(
x = EventSource();
x.storePrevious.dopost;
x.fire(2);
x.fire(3);
)
::

## storePreviousWithT: store current and previous event in an array with the event time stamp. The initial valuea are assumed to be [0.0,0.0].
code::
(
x = EventSource();
x.storePreviousWithT.dopost;
x.fire(2);
x.fire(3);
)
::

## changes: Output only if new value different from last value.
code::
(
x = EventSource();
x.changes.dopost;
x.fire(2);
x.fire(2);
x.fire(2);
x.fire(2);
x.fire(2);
x.fire(2);
x.fire(3);
)
::

## changedDirection: Output only when going from increasing to decreasing or descreasing to increasing.
code::
(
x = EventSource();
x.changedDirection.dopost;
x.fire(2);
x.fire(3);
x.fire(4);
x.fire(2);
)
::

## decreasing: Output only when values are decreasing.

code::
(
x = EventSource();
x.decreasing.dopost;
x.fire(2);
x.fire(3);
x.fire(4);
x.fire(2);
)
::

## increasing: Output only when values are increasing.

code::
(
x = EventSource();
x.decreasing.dopost;
x.fire(2);
x.fire(3);
x.fire(4);
x.fire(2);
)
::

## withinRange: Output only values between a and b.

code::
(
x = EventSource();
x.withinRange(2,3).dopost;
x.fire(1);
x.fire(2.5);
)
::

## matchVal: Output only if event matches one of the values in the array, in which case the index of the value is returned.

code::
(
x = EventSource();
x.matchVal([1,2,3,4]).dopost;
x.fire(1);
x.fire(2.5);
)
::

## threshold: Output when value crosses threshold.
code::
(
x = EventSource();
x.threshold(0.5).dopost;
x.fire(0);
x.fire(1);
x.fire(0);
)
::

## thresholdUp: Output when value crosses threshold while increasing.
code::
(
x = EventSource();
x.thresholdUp(0.5).dopost;
x.fire(0);
x.fire(1);
x.fire(0);
)
::

## thresholdDown: Output when value crosses threshold while decreasing.
code::
(
x = EventSource();
x.thresholdDown(0.5).dopost;
x.fire(0);
x.fire(1);
x.fire(0);
)
::


## neventsWithinT: Output a Unit if n consecutive events arrive within a period of waitTime seconds. Can be used for instance to detect double-clicks.
code::
(
x = EventSource();
x.neventsWithinT(1.0,3).dopost;
fork{
	x.fire(1);
	x.fire(1);
	//nothing goes through
	1.1.wait;
	x.fire(1);
	x.fire(1);
	x.fire(1);
	//now you get a Unit
}
)
::

## speed: Output speed at which values are arriving.
code::
(
x = EventSource();
x.speed.dopost;
x.fire(1);
x.fire(2.5);
)
::

## route: Returns an array of n event stream where events will be sent according to the values of select.

n: number of event streams to route to
select: event stream selects to which of the output event streams to send events

This is similar has having a code::Out.ar(\bus.kr(0), ugen)::, it allows to choose where you are routing the input.

code::

(
var select;
//original source
x = EventSource();
//the event source that selects where the orignal source goes
select = EventSource();
x.route(4,select).do{ |es, i|
	es.do{ |v| postln("outputting to selection "++i++": "++v) }
};
select.fire(0);
x.fire(1);
select.fire(2);
x.fire(33);
)
::

slowdown: Only fire if new value arrived at least t seconds after last value. Does not remember values in between.

code::
(
x = EventSource();
x.slowdown(0.1).dopost;
fork{
x.fire(1);
x.fire(2.5);
x.fire(3);
0.2.wait;
x.fire(22)
}
)
::

::

instancemethods::

method::do
Run f every time a new event arrives.

method::hold
argument::initialValue
The current ('now') value for the returned FPSignal.
returns:: An FPSignal that holds the last value of the EventSource

method::collect
returns::A new EventStream, that for every event that this EventStream fires, that one will fire an event that is the result of applying 'f' to this EventStream's event.
discussion::
code::
(
x = EventSource();
y = x.collect( _*100 );
y.do(_.postln);
x.fire(2)
)
::

method::select
returns::A new EventStream that propagates a subset of the events that this EventStream fires.
discussion::
code::
(
x = EventSource();
y = x.select( _ < 2 );
y.do(_.postln);
x.fire(1);
x.fire(4);
)
::

method::fold
Allows one, in a functional manner, to respond to an event while taking into account past events. For every event t, f is called with arguments (u, t), where u is initially the value of the 'initial' parameter, and subsequently the result of the previous application of f.
returns:: A new EventStream that, for every event t fired by the original EventStream, fires the result of the application of f (which will also be the next value of u passed to it). Often 'u' will be an object representing some accumulated state.
discussion::
An EventStream that sums all the integer values fired by the parent EventStream.
code::
(
x = EventSource();
y = x.fold( 0, {|state,b| state + b });
y.do(_.postln);
x.fire(1);
x.fire(4);
x.fire(7)
)
::

method::flatCollect
Create a new EventStream that consists of the events of the EventStreams returned by f. f is applied on every event of the original EventStream, and its returned EventStream is used until the next event fired by the original EventStream, at which time the previously returned EventStream is no longer used and a new one is used instead.

note::
Because of SuperCollider's lack of weak references, if you create a new EventSource in the function passed to flatCollect there will be a build up of EventSources, and the handler functions of those EventSources will be run every time the parent EventSource is fired. To avoid this use an flatCollectR instead.

::
argument::f
f the function that is applied for every event to produce the next segment of the resulting EventStream.
discussion::
code::
(
x = EventSource();
y = EventSource();
z = EventSource();
w = x.flatCollect{ |v|
 if(v==0){y}{z}
};
w.do(_.postln);
)
(
//will get value from y
x.fire(0);
y.fire(1);
z.fire(4);
)
(
//will get value from z
x.fire(1);
y.fire(1);
z.fire(4);
)

//this is the correct syntax but will cause a build up of EventSources
(
x = EventSource();
y = EventSource();
z = x.flatCollect{ |x| y.collect{ |y| "Ping".postln; [x,y] } };
z.do(_.postln);
)
//run this multiple times
x.fire(1);
//you will get multiple pings, when you should have only one.
y.fire(4);

//Now with an flatCollectR
(
x = EventSource();
y = EventSource();
z = x.flatCollectR{ |x| y.collect{ |y| "Ping".postln; [x,y] } };
z.do(_.postln);
)
//run this multiple times
x.fire(1);
//only one ping.
y.fire(4);

::

method::flatCollectR
Create a new EventStream that consists of the events of the EventStreams returned by f. f is applied on every event of the original EventStream, and its returned EventStream is used until the next event fired by the original EventStream, at which time the previously returned EventStream is no longer used and a new one is used instead.

This method differs from flatCollectR such that when receiving a new EventStream it will disconnect the old EventStream from it's parent, therefore it should only used when creating a new EventStream inside the flatCollect function:

code::

//here you should use flatCollect
// no new EventSources created inside flatCollect
(
x = EventSource();
y = EventSource().collect(_+10);
z = EventSource().collect(_+20);
w = x.flatCollect{ |v|
 if(v==0){y}{z}
};
w.do(_.postln);
)
(
//will get value from y
x.fire(0);
y.fire(1);
z.fire(4);
)

// here you should use flatCollectR
// y.collect creates a new EventSource
(
x = EventSource();
y = EventSource();
z = x.flatCollectR{ |x| y.collect{ |y| [x,y] } };
z.do(_.postln);
)
x.fire(1);
y.fire(4);
::


method::|
Merges the output of the two EventSources.
discussion::
code::
(
x = EventSource();
y = EventSource();
z = x | y;
z.do({ |x| ("received: "++x).postln});
x.fire(1);
y.fire(4);
)
::



method::merge
the same as code::|::

method::takeWhile
returns::An EventSource that will fire the events coming from the parent until f evaluates to false, at which point it will not fire anything else.
discussion::
code::
(
x = EventSource();
z = x.takeWhile( _ < 10);
z.do({ |x| ("received: "++x).postln});
x.fire(1);
x.fire(4);
x.fire(7);
x.fire(13);
x.fire(4);
)
::

method::remove

Disconnects this EventStream from the parent EventStream (if it has a parent). If the EventStream is not assigned to any variable anymore it will be gc'ed.

code::
(
x = EventSource();
y = x.collect(_+10);
y.do(postln(_));
x.fire(2);
)

(
y.remove;
x.fire(3);
//nothing is posted
)

//now the EventSource that was assigned to y can be gc'ed.
y = nil;
::

method::reset

Removes all listeners. This will disconnect this EventSource from the rest of the chain that depends on it, and the rest of the chain will be gc'ed.

code::
(
x = EventSource();
y = x.collect(_+10);
y.do(postln(_));
x.fire(2);
)

(
x.reset;
x.fire(3);
//nothing is posted
)
::

method::bus

create a bus and add a function to the event stream that updates the bus.

returns:: Some( Tuple2( Bus, Function ) ). The function is returned to be able to stop updating the Bus in the future. If the server is not running returns None.

code::
x = { SinOsc.ar( \freq.kr(400) )*0.1 }.play

(
y = EventSource();
b = y.bus(s, 900);
//b might be None if the server is not running.
b.do{ |z| x.map(\freq, z.at1) }
)

//change freq to 200
y.fire( 200 );
::

Examples::

code::
//Using a timer
(
// args delta (s), maxTime(s)
// will output every delta seconds until maxTime is reached.
x = TimerES(1,10);
x.do({ |x| ("received: "++x).postln});
)

::