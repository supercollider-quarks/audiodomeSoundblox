CLASS:: EventSource
summary:: Implementation of Functional Reactive Programming.
categories:: FP
related:: Classes/FPSignal

description::

This is a port of the reactive-core library for Scala into SuperCollider.

For more info see:

http://www.reactive-web.co.cc/core/EventStream

note::
Right now because sc does not have weak references, this can cause a build up of EventStreams when using flatCollect.
::


An EventStream is a source of events (arbitrary values sent to listener functions). You can fire events from it, you can react to events with any behavior, and you can create derived EventStreams, whose events are based on the original EventStream.

An EventStream is like a collection in the sense that it consists of multiple values. However, unlike actual collections, the values are not available upon request; they occur whenever they occur. Nevertheless, many operations that apply to collections apply to event streams. To react to events, use foreach or foldLeft. To create derived, transformed EventStreams, use map, flatMap, filter, foldLeft, and the | (union) operator. Note that you can of course use for comprehensions as syntactic sugar for many of the above.

There are only two ways to stop an EventSource from continuing to process events:
list::
## the functional way is to use takeWhile
## the imperative way is to call .remove on the event stream.
::

subsection::Type Classes
EventSource is an instance of the Functor Type Class. It does not implement the 'pure' function therefore it is not a Monad or an Applicative Functor. It does implement the 'bind' or '>>=' function.

instancemethods::

method::do
Run f every time a new event arrives.

method::hold
argument::initialValue
The current ('now') value for the returned FPSignal.
returns:: An FPSignal that holds the last value of the EventSource

method::collect
returns::A new EventStream, that for every event that this EventStream fires, that one will fire an event that is the result of applying 'f' to this EventStream's event.
discussion::
code::
(
x = EventSource();
y = x.collect( _*100 );
y.do(_.postln);
x.fire(2)
)
::

method::select
returns::A new EventStream that propagates a subset of the events that this EventStream fires.
discussion::
code::
(
x = EventSource();
y = x.select( _ < 2 );
y.do(_.postln);
x.fire(1);
x.fire(4);
)
::

method::fold
Allows one, in a functional manner, to respond to an event while taking into account past events. For every event t, f is called with arguments (u, t), where u is initially the value of the 'initial' parameter, and subsequently the result of the previous application of f.
returns:: A new EventStream that, for every event t fired by the original EventStream, fires the result of the application of f (which will also be the next value of u passed to it). Often 'u' will be an object representing some accumulated state.
discussion::
An EventStream that sums all the integer values fired by the parent EventStream.
code::
(
x = EventSource();
y = x.fold( 0, {|state,b| state + b });
y.do(_.postln);
x.fire(1);
x.fire(4);
x.fire(7)
)
::

method::flatCollect
Create a new EventStream that consists of the events of the EventStreams returned by f. f is applied on every event of the original EventStream, and its returned EventStream is used until the next event fired by the original EventStream, at which time the previously returned EventStream is no longer used and a new one is used instead.

note::
Because of SuperCollider's lack of weak references, if you create a new EventSource in the function passed to flatCollect there will be a build up of EventSources, and the handler functions of those EventSources will be run every time the parent EventSource is fired. To avoid this use an flatCollectR instead.

::
argument::f
f the function that is applied for every event to produce the next segment of the resulting EventStream.
discussion::
code::
(
x = EventSource();
y = EventSource();
z = EventSource();
w = x.flatCollect{ |v|
 if(v==0){y}{z}
};
w.do(_.postln);
)
(
//will get value from y
x.fire(0);
y.fire(1);
z.fire(4);
)
(
//will get value from z
x.fire(1);
y.fire(1);
z.fire(4);
)

//this is the correct syntax but will cause a build up of EventSources
(
x = EventSource();
y = EventSource();
z = x.flatCollect{ |x| y.collect{ |y| "Ping".postln; [x,y] } };
z.do(_.postln);
)
//run this multiple times
x.fire(1);
//you will get multiple pings, when you should have only one.
y.fire(4);

//Now with an flatCollectR
(
x = EventSource();
y = EventSource();
z = x.flatCollectR{ |x| y.collect{ |y| "Ping".postln; [x,y] } };
z.do(_.postln);
)
//run this multiple times
x.fire(1);
//only one ping.
y.fire(4);

::

method::flatCollectR
Create a new EventStream that consists of the events of the EventStreams returned by f. f is applied on every event of the original EventStream, and its returned EventStream is used until the next event fired by the original EventStream, at which time the previously returned EventStream is no longer used and a new one is used instead.

This method differs from flatCollectR such that when receiving a new EventStream it will disconnect the old EventStream from it's parent, therefore it should only used when creating a new EventStream inside the flatCollect function:

code::

//here you should use flatCollect
// no new EventSources created inside flatCollect
(
x = EventSource();
y = EventSource().collect(_+10);
z = EventSource().collect(_+20);
w = x.flatCollect{ |v|
 if(v==0){y}{z}
};
w.do(_.postln);
)
(
//will get value from y
x.fire(0);
y.fire(1);
z.fire(4);
)

// here you should use flatCollectR
// y.collect creates a new EventSource
(
x = EventSource();
y = EventSource();
z = x.flatCollectR{ |x| y.collect{ |y| [x,y] } };
z.do(_.postln);
)
x.fire(1);
y.fire(4);
::


method::|
Merges the output of the two EventSources.
discussion::
code::
(
x = EventSource();
y = EventSource();
z = x | y;
z.do({ |x| ("received: "++x).postln});
x.fire(1);
y.fire(4);
)
::



method::merge
the same as code::|::

method::takeWhile
returns::An EventSource that will fire the events coming from the parent until f evaluates to false, at which point it will not fire anything else.
discussion::
code::
(
x = EventSource();
z = x.takeWhile( _ < 10);
z.do({ |x| ("received: "++x).postln});
x.fire(1);
x.fire(4);
x.fire(7);
x.fire(13);
x.fire(4);
)
::

method::remove

Disconnects this EventStream from the parent EventStream (if it has a parent). If the EventStream is not assigned to any variable anymore it will be gc'ed.

code::
(
x = EventSource();
y = x.collect(_+10);
y.do(postln(_));
x.fire(2);
)

(
y.remove;
x.fire(3);
//nothing is posted
)

//now the EventSource that was assigned to y can be gc'ed.
y = nil;
::

method::reset

Removes all listeners. This will disconnect this EventSource from the rest of the chain that depends on it, and the rest of the chain will be gc'ed.

code::
(
x = EventSource();
y = x.collect(_+10);
y.do(postln(_));
x.fire(2);
)

(
x.reset;
x.fire(3);
//nothing is posted
)
::

Examples::

code::
//Using a timer
(
// args delta (s), maxTime(s)
// will output every delta seconds until maxTime is reached.
x = TimerES(1,10);
x.do({ |x| ("received: "++x).postln});
)

::