{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf480
{\fonttbl\f0\fnil\fcharset77 Monaco;\f1\fswiss\fcharset77 Helvetica;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue0;\red0\green0\blue191;
\red96\green96\blue96;\red0\green115\blue0;}
\deftab720
\pard\pardeftab720\ql\qnatural

\f0\fs18 \cf2 // jedem W\'9frfel ist eine Geraeuschfamilie zugeordnet\cf3 \
\
\pard\pardeftab560\ql\qnatural
\cf3 \
(\
\cf4 Server\cf3 .default = s = \cf4 Server\cf3 .internal;\
\
s.waitForBoot\{\
q = ();\
\
\cf2 // joseph\cf3 \
\cf2 // q.directory = "/Network/Servers/stitch/srv/nfs/volume1/home/till/samples/";\cf3 \
\
\cf2 // till\cf3 \
\cf2 // q.directory = "/localvol/sound/share/audiosamples/koelnKalk/";\cf3 \
\
\cf2 // hubert\cf3 \
q.directory = \cf5 "/Users/till/Documents/koelnKalk/sequencer/"\cf3 ;\
\
\cf2 /* open directory\
"open %".format(q.directory).unixCmd; // */\cf3 \
\
\
\
\cf2 // For each name given below, q.directory should have a directory containing files named 1-*.aiff, 2-*.aiff, etc. \cf3 \
\cf2 // If the files are n-channel, currently only the first channel is used.\cf3 \
\cf2 // be sure to have only .aiff files here. Neither wav, nor mp3 are supported yet. If you need to convert files easily, use e.g. Max ({\field{\*\fldinst{HYPERLINK "http://sbooth.org/Max/"}}{\fldrslt 
\f1\fs22 \cf2 http://sbooth.org/Max/}}), or sndfile-convert.\cf3 \
\
\cf2 // Link directory names to colors. Only given colores will be recognized, all other cubes are ignored.\cf3 \
q.colorToName = (\
	lightGreen: \cf5 \\sn\cf3 ,\
	red: \cf5 \\bass\cf3 , \
	blue: \cf5 \\chords\cf3 , \
	yellow: \cf5 \\hh\cf3 ,\
	orange: \cf5 \\synth\cf3 ,\
	green: \cf5 \\bd\cf3 \
);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf3 \
\pard\pardeftab560\ql\qnatural
\cf2 // the audiochannels to which the cube speakers are attached to\cf3 \
q.cubeChannels = (\
	yellow:		0,\
	lightGreen:	1,\
	blue:		2,\
	orange:		3,\
	red:			4,\
	green:		7\
);\
\
\
\cf2 /*q.cubeChannels = (\
	yellow:		7,\
	lightGreen:	7,\
	blue:		7,\
	orange:		7,\
	red:			7,\
	green:		7\
);\
*/\cf3 \
\
\
q.filenames = ();\
q.colorToName.keysValuesDo\{\cf4 |color, subdirname|\cf3 \
	q.filenames[color] = 6.collect\{\cf4 |i|\cf3 \
		\cf5 "%/%.aif"\cf3 .format(subdirname, i+1);\
	\}\
\};\
\
\cf2 /*\
q.filenames.printAll // */\cf3 \
\
\
\
q.buffers = q.filenames.collect\{\cf4 |cubefiles|\cf3 \
	cubefiles.collect\{\cf4 |name|\cf3 \
		\cf4 Buffer\cf3 .readChannel(s, q.directory ++ name, channels: [0], action:\{\cf5 "file % read.\\n"\cf3 .postf(name) \})\
\cf2 //		Buffer.read(s, q.directory ++ name, action:\{"file % read.\\n".postf(name) \})\cf3 \
	\}\
\};\
\
\cf2 // only first channel of the file is read \cf3 \
\
\cf2 /* test\
q.buffers.choose.choose.play \
\
q.sfile = SoundFile.openRead(q.directory ++ q.filenames[\\green][6]);\
\
q.sfile.numChannels\
q.sfile.close;\
\
\
// */\cf3 \
\
\}\
)\
\
\
(\
q.cubes = q.colorToName.collect\{\cf4 |v, color|\cf3  \cf4 BufferBlock\cf3 (color, 0, q.buffers[color], q.cubeChannels[color])\};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\ql\qnatural\pardirnatural
\cf4 BufferBlock\cf3 .sendSynth;\
\pard\pardeftab560\ql\qnatural
\cf3 q.buffers.asArray.flatten.do\{\cf4 _\cf3 .normalize\};\
)\
\
(\
s.bind\{\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf4 BufferBlock\cf3 .startClock;\
\pard\pardeftab560\ql\qnatural
\cf3 q.cubes.do(\cf4 _\cf3 .play);\
\}\
)\
\
(\
s.bind\{\
q.cubes.do(\cf4 _\cf3 .stop);\
\}\
)\
\
\
q.cubes.do\{\cf4 |cube|\cf3 \
	cube.set(\cf6 \\amp\cf3 , 1);\
	\cf2 //cube.out = 0\cf3 \
\};\
\
\
\cf2 //////////////////////\cf3 \
\cf2 // Start SETO\cf3 \
\
(\
q.seto = \cf4 SETO_OSCTUIOServer\cf3 (\cf5 "2Dobj"\cf3 , \cf4 nil\cf3 , \cf4 JITseto\cf3 , \cf4 SETOIDistance\cf3 ); \
q.seto.start;\
\
\cf4 Tdef\cf3 (\cf6 \\player\cf3 , \{loop\{\
	0.03.wait;\
	\cf2 // bd\cf3 \
	q.cubes.green.setFace(126, \cf6 \\amps\cf3 , 1);q.cubes.green.setFace(126, \cf6 \\filterFreqs\cf3 , 260000);\
\
\
	q.cubes.blue.setFace(180, \cf6 \\amps\cf3 , 1);q.cubes.blue.setFace(180, \cf6 \\filterFreqs\cf3 , 260000);\
	q.cubes.red.setFace(108, \cf6 \\amps\cf3 , 1);q.cubes.red.setFace(108, \cf6 \\filterFreqs\cf3 , 260000);\
	q.cubes.lightGreen.setFace(144, \cf6 \\amps\cf3 , 1);q.cubes.lightGreen.setFace(144, \cf6 \\filterFreqs\cf3 , 260000);\
	q.cubes.orange.setFace(162, \cf6 \\amps\cf3 , 1);q.cubes.orange.setFace(162, \cf6 \\filterFreqs\cf3 , 260000);\
	q.cubes.yellow.setFace(198, \cf6 \\amps\cf3 , 1);q.cubes.yellow.setFace(198, \cf6 \\filterFreqs\cf3 , 260000);\
\}\}).play;\
\
\cf4 JITseto\cf3 .action = \{\cf4 |me|\cf3 \
	\cf4 var\cf3  cube = q.cubes.detect\{\cf4 |cube|\cf3  cube.ids.includes(me.id)\};\
	cube.notNil.if\{\
		\cf2 //cube.color.postln;\cf3 \
		\cf2 //cube.setFace(me.id, \\amps, ((sin(me.rotEuler.first) * 0.95).abs + 0.05));\cf3 \
		cube.setFace(me.id, \cf6 \\amps\cf3 , me.pos.first.linlin(0, 1, 1, 1));\
		cube.setFace(me.id, \cf6 \\filterFreqs\cf3 , sin(me.rotEuler.first*0.5).abs.linexp(0, 1, 1500, 260000));\
		\cf2 //cube.setFace(me.id, \\amps, 0.9)\cf3 \
	\}\
\};\
\
\
\
\cf2 /*\
JITseto.action = nil; // */\cf3 \
\cf2 //JITseto.action = \{|me| me.postln\}; // */\cf3 \
)\
\
\
\cf2 ///////////////////////\cf3 \
\cf2 // Midi Mixer\cf3 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf4 MIDIClient\cf3 .init;\
\cf4 MIDIIn\cf3 .connect;\
\
(\
\cf4 MIDIIn\cf3 .control = \{\cf4 |port, chan, ctlNum, val|\cf3  \
	[chan, ctlNum, val].postln;\
	\
	(ctlNum == 7).if\{ \cf2 // fader\cf3 \
		(chan == 8).if\{ \cf2 // master (right-most)\cf3 \
			q.cubes.do\{\cf4 |cube|\cf3 \
				cube.set(\cf6 \\masterAmp\cf3 , val.linlin(0, 127, 0, 1))	\
			\}\
		\};\
\
		(chan < 8).if\{ \cf2 // red (left-most)\cf3 \
			[chan, val].postln;\
			q.cubes[q.cubeChannels.findKeyForValue(chan)].set(\cf6 \\amp\cf3 , val.linlin(0, 127, 0, 1))	\
		\};\
	\};\
	\
	(ctlNum == 17).if\{ \cf2 // lower button -> mute\cf3 \
		(chan == 8).if\{ \cf2 // master (right-most)\cf3 \
			q.cubes.do\{\cf4 |cube|\cf3 \
				cube.set(\cf6 \\masterMute\cf3 , val.linlin(0, 127, 0, 1))	\
			\}\
		\};\
\
		(chan < 8).if\{ \cf2 // red (1- rightmost)\cf3 \
			q.cubes[q.cubeChannels.findKeyForValue(chan)].set(\cf6 \\mute\cf3 , val.linlin(0, 127, 0, 1))	\
		\};\
	\};\
	\
	(ctlNum == 10).if\{ \cf2 // knob\cf3 \
		(chan == 8).if\{ \cf2 // global rate -> master (right-most)\cf3 \
			\cf4 BufferBlock\cf3 .phase.set(\cf6 \\rate\cf3 , val.linlin(0, 127, 0.5, 2).round(0.01).postln)\
		\};\
		(chan == 3).if\{ \cf2 // global shift -> left to master\cf3 \
			q.cubes[\\orange].do\{\cf4 |cube|\cf3 \
				cube.set(\cf6 \\pitch\cf3 , val.linlin(0, 127, 0.5, 2).round(0.1).postln)	\
			\}\
		\};\
	\};\
\}\
\pard\pardeftab560\ql\qnatural
\cf3 )\
\
q.cubes.do\{\cf4 |cube|\cf3 \
	cube.synthParams.add(\cf6 \\masterMute\cf3  -> [0]);\
	cube.synthParams.add(\cf6 \\mute\cf3  -> [0]);\
\}\
\
q.cubes[3].play\
q.cubes[3].out = 0\
\
q.cubes[3].stop\
\
\
\
\
\
\
\
q.cubes.do\{\cf4 |cube|\cf3 \
	cube.set(\cf6 \\amps\cf3 , 3);\
\}\
\
q.cubes.do\{\cf4 |cube|\cf3 \
	cube.stop;\
\}\
\
q.cubes[3].play\
q.cubes[3].out = 0\
q.cubes[3].stop\
\
q.cubes[1].set(side: 2, what: \cf6 \\rates\cf3 , val: 0.5);\
\
6.do\{\cf4 |i|\cf3 \
	q.cubes[1].set(side: i, what: \cf6 \\amps\cf3 , val: 0.5);\
\}\
\
6.do\{\cf4 |i|\cf3 \
	q.cubes[1].set(side: i, what: \cf6 \\rates\cf3 , val: rrand(0.5, 2.0));\
\}\
\
\
6.do\{\cf4 |i|\cf3 \
	q.cubes[0].set(side: i, what: \cf6 \\rates\cf3 , val: rrand(1, 4.0));\
\}\
\
\
\
x.setn(\cf6 \\amps\cf3 , [1, 0, 0, 0, 0, 0])\
x.setn(\cf6 \\amps\cf3 , [0, 0, 1, 0, 0, 0])\
x.setn(\cf6 \\amps\cf3 , 1!6)\
\
x.setn(\cf6 \\amps\cf3 , [10, 0, 0, 0, 0, 0, 0])\
\
\
x.setn(\cf6 \\amps\cf3 , [1, 1, 1, 1, 1, 1, 1])}