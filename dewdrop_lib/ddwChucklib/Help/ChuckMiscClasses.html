<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="824.42">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 20.0px Helvetica}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
    p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
    p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
    p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #bf0000}
    p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #007300}
    p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 18.0px Helvetica}
    p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 15.0px Helvetica}
    p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
    p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #0000bf}
    p.p11 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica}
    span.s1 {text-decoration: underline}
    span.s2 {color: #0000bf}
    span.s3 {color: #007300}
    span.s4 {color: #000000}
    span.s5 {font: 14.0px Helvetica}
    span.s6 {color: #606060}
    span.s7 {color: #bf0000}
    span.s8 {font: 12.0px Helvetica}
    span.Apple-tab-span {white-space:pre}
  </style>
</head>
<body>
<p class="p1"><b>Chucking support classes</b></p>
<p class="p2"><br></p>
<p class="p3">Four types, categorized by index type and creation method:</p>
<p class="p2"><br></p>
<p class="p3"><span class="s1"><b>Index<span class="Apple-tab-span">	</span>Creation<span class="Apple-tab-span">	</span>Abstract class name</b></span></p>
<p class="p3">Integer (array)<span class="Apple-tab-span">	</span>prNew <span class="Apple-tab-span">	</span>AbstractChuckArray</p>
<p class="p3">Integer<span class="Apple-tab-span">	</span>automatic <span class="Apple-tab-span">	</span>AbstractChuckNewArray</p>
<p class="p3">Symbol (IdentityDictionary)<span class="Apple-tab-span">	</span>prNew <span class="Apple-tab-span">	</span>AbstractChuckDict</p>
<p class="p3">Symbol<span class="Apple-tab-span">	</span>automatic <span class="Apple-tab-span">	</span>AbstractChuckNewDict</p>
<p class="p2"><br></p>
<p class="p3"><b>prNew types</b> require you to create the instance explicitly using prNew before chucking something into it. Intended for objects and that require only a few instances that are reused over and over (like VP, VoicerProxy). The use of prNew prevents you from accidentally creating extra instances that might mess up a GUI, for instance.</p>
<p class="p2"><br></p>
<p class="p4"><span class="s2">VC</span>(<span class="s3">\buzz</span>) =&gt; <span class="s2">VP</span>.prNew(0);<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">For array prNew types, common usage is to create the arrayed instances during initialization:</p>
<p class="p2"><br></p>
<p class="p4">6.do({ <span class="s2">|i|</span></p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="s2">VoicerProxy</span>.new =&gt; <span class="s2">VP</span>.prNew(i);</p>
<p class="p5"><span class="s4"><span class="Apple-tab-span">	</span></span>// here you can make a gui for the new VoicerProxy if you want</p>
<p class="p4">});</p>
<p class="p4"><span class="s2">VC</span>(<span class="s3">\buzz</span>) =&gt; <span class="s2">VP</span>(0);<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3"><b>Automatic creation types</b> are for objects which may have an unlimited number of instances (such as process prototypes or bound processes):</p>
<p class="p2"><br></p>
<p class="p6"><span class="s2">PR</span><span class="s4">(</span>\aiMel<span class="s4">) =&gt; </span><span class="s2">BP</span><span class="s4">(</span>\mel1<span class="s4">);<span class="Apple-converted-space"> </span></span></p>
<p class="p2"><br></p>
<p class="p3">All objects have these variables in common:</p>
<p class="p2"><br></p>
<p class="p3"><i>collIndex</i>: the index into the class's collection</p>
<p class="p3"><i>value</i>: the object stored at this index (shortcut reference is .v)</p>
<p class="p2"><br></p>
<p class="p3"><i>aChuckClass.collection</i>: returns all the objects defined for this class</p>
<p class="p3"><i>aChuckClass.listKeys</i>: list all the symbolic keys defined for this class. Works only for symbolically-indexed classes.</p>
<p class="p2"><br></p>
<p class="p7"><b>The classes<span class="Apple-converted-space"> </span></b></p>
<p class="p2"><br></p>
<p class="p8"><b>Voicer and Synth management</b></p>
<p class="p2"><br></p>
<p class="p3"><span class="s5"><b>Fact(\symbol)</b></span> -- factory -- automatic creation<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">A factory creates an object that depends on other support objects. For example, a voicer may use buffers as wavetables or samples. The factory for this voicer is responsible for creating the buffers and returning the voicer.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">Requires an Environment or Event containing a make function for creation of the support objects, and a free function to free the support objects. The Fact's free method will free the value, but you have to free everything you create in the environment.</p>
<p class="p2"><br></p>
<p class="p3">The environment should contain a type key to indicate what kind of object a factory returns. Currently supported are:</p>
<p class="p2"><br></p>
<p class="p3"><i>\voicer</i> -- returns a voicer and stores support objects.</p>
<p class="p3"><i>\bp</i> -- creates a bound process. Since the BP maintains its own objects set, there is no need to store objects in the factory's environment.</p>
<p class="p2"><br></p>
<p class="p3">The ~target environment variable is reserved for the target on which the Voicer will play. Usually this will be a MixerChannel; if not, it should be a Group or Server.</p>
<p class="p2"><br></p>
<p class="p4">(make: {</p>
<p class="p4"><span class="Apple-tab-span">	</span>~target = <span class="s2">MixerChannel</span>(<span class="s6">"ghostly"</span>, s, 1, 2, level:0.1);</p>
<p class="p5"><span class="s4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// note: I define my Instr's in the global Instr library</p>
<p class="p5"><span class="s4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// (.rtf files held in ./Instr/), then reference them by name here.</p>
<p class="p5"><span class="s4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// for this example, I can't assume you have this Instr.</p>
<p class="p4"><span class="s2"><span class="Apple-tab-span">	</span>Instr</span>([<span class="s3">\analog</span>, <span class="s3">\ghostly</span>], { <span class="s2">arg</span> freq, gate, freqlag, attacktime, decaytime, env, vsense, mul;</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s2">var</span> amp;</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>amp = <span class="s2">Sensitivity</span>.kr(1, <span class="s2">Latch</span>.kr(gate, gate), vsense);</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s2">Mix</span>.ar(<span class="s2">Formlet</span>.ar(<span class="s2">PinkNoise</span>.ar([0.2, 0.2]), freq*2, attacktime, decaytime, mul))</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>* <span class="s2">EnvGen</span>.kr(env, gate, doneAction:2, levelScale:amp*2.5)</p>
<p class="p4"><span class="Apple-tab-span">	</span>}, [<span class="s3">\freq</span>, [0, 1], [0, 2], [0.001, 2, <span class="s3">\exponential</span>], [0.001, 2, <span class="s3">\exponential</span>],</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s2">EnvSpec</span>(<span class="s2">Env</span>.adsr(0.01, 1, 0.75, 0.1)), [0, 1], [0, 1]]);</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="s2">Voicer</span>(10, <span class="s2">Instr</span>.[[<span class="s3">\analog</span>, <span class="s3">\ghostly</span>]], [<span class="s3">\attacktime</span>, `0.002, <span class="s3">\decaytime</span>, `0.9186, <span class="s3">\vsense</span>, `0.787, <span class="s3">\mul</span>, `0.535], target:~target).latency_(0.5)</p>
<p class="p4">},</p>
<p class="p4">free: {</p>
<p class="p4"><span class="Apple-tab-span">	</span>~target.free</p>
<p class="p4">}, type: <span class="s3">\voicer</span>) =&gt; <span class="s2">Fact</span>(<span class="s3">\ghost</span>);</p>
<p class="p2"><br></p>
<p class="p3"><span class="s5"><b>VC(\symbol)</b></span> -- VoiCer -- automatic creation<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">A placeholder for a voicer. Has an additional instance variable, env, populated when you chuck a factory into it. ***</p>
<p class="p2"><br></p>
<p class="p5"><span class="s2">Fact</span><span class="s4">(</span><span class="s3">\ghost</span><span class="s4">) =&gt; </span><span class="s2">VC</span><span class="s4">(</span><span class="s3">\ghost</span><span class="s4">);<span class="Apple-converted-space">  </span></span>// creates the voicer and its mixerchannel</p>
<p class="p5"><span class="s2">VC</span><span class="s4">(</span><span class="s3">\ghost</span><span class="s4">).free;<span class="Apple-converted-space">  </span></span>// frees both</p>
<p class="p2"><br></p>
<p class="p3"><span class="s5"><b>SY(\symbol)</b></span> -- SYnth -- automatic creation</p>
<p class="p2"><br></p>
<p class="p3">A placeholder for a synthdef name and the target onto which it should play. Works exactly like VC except that the Fact needs to include ~out if the target isn't a MixerChannel:</p>
<p class="p2"><br></p>
<p class="p3">- ~target: the target (MixerChannel or Group)</p>
<p class="p3">- ~out: if ~target is a Group, provide a bus number for the audio</p>
<p class="p2"><br></p>
<p class="p4">(make: {</p>
<p class="p4"><span class="Apple-tab-span">	</span>~target = <span class="s2">MixerChannel</span>(<span class="s3">\synthTest</span>, s, 2, 2);</p>
<p class="p6"><span class="s4"><span class="Apple-tab-span">	</span></span>\default</p>
<p class="p4">}, free: { ~target.free }) =&gt; <span class="s2">Fact</span>(<span class="s3">\defaultSynth</span>);</p>
<p class="p9"><br></p>
<p class="p6"><span class="s2">Fact</span><span class="s4">(</span>\defaultSynth<span class="s4">) =&gt; </span><span class="s2">SY</span><span class="s4">(</span>\default<span class="s4">);</span></p>
<p class="p4"><span class="s2">SY</span>(<span class="s3">\default</span>).free;</p>
<p class="p2"><br></p>
<p class="p8"><b>GUI management</b></p>
<p class="p2"><br></p>
<p class="p3"><span class="s5"><b>VP(int)</b></span> -- VoicerProxy -- prNew<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">Used as a GUI model for voicers. Chucking a voicer in changes the GUI display, as well as the voicer used for any processes using this proxy. Typical use is to create a small array so that all the GUIs will fit on one window and reuse them throughout a performance.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">Should be initialized thus:</p>
<p class="p2"><br></p>
<p class="p4"><span class="s2">VoicerProxy</span>.new =&gt; <span class="s2">VP</span>.prNew(0);</p>
<p class="p2"><br></p>
<p class="p3">Once it exists, there is a short form to instantiate a voicer and place it into a proxy:</p>
<p class="p2"><br></p>
<p class="p4"><span class="s2">Fact</span>(<span class="s3">\ghost</span>) =&gt; <span class="s2">VP</span>(0);</p>
<p class="p5">// equivalent to:</p>
<p class="p4"><span class="s2">Fact</span>(<span class="s3">\ghost</span>) =&gt; <span class="s2">VC</span>(<span class="s3">\ghost</span>) =&gt; <span class="s2">VP</span>(0);</p>
<p class="p2"><br></p>
<p class="p3">Typical code fragment to generate a panel of reusable Voicer GUIs. You only have to do this once when loading up for a live set!</p>
<p class="p2"><br></p>
<p class="p4">~masterLayout = <span class="s2">MultiPageLayout</span>(<span class="s6">"chucking demo"</span>).front;</p>
<p class="p9"><br></p>
<p class="p5">// voicerproxies -- creating this gui is time sensitive</p>
<p class="p10">Routine<span class="s4">({</span></p>
<p class="p4"><span class="Apple-tab-span">	</span>6.do({ <span class="s2">|i|</span></p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s2">VoicerProxy</span>.new =&gt; <span class="s2">VP</span>.prNew(i);</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>3.do({ <span class="s2">VP</span>(i).v.addControlProxy(<span class="s2">nil</span>, <span class="s2">true</span>) });</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s2">VP</span>(i).v.gui(~voicerFlow);</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0.2.wait;</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>~voicerFlow.recursiveResize;</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0.2.wait;</p>
<p class="p4"><span class="Apple-tab-span">	</span>});</p>
<p class="p4">}).play(<span class="s2">AppClock</span>);</p>
<p class="p2"><br></p>
<p class="p3"><span class="s5"><b>MCG(int)</b></span> -- MixerChannel Gui -- prNew<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">Common use is to define a fixed number of mixer GUI slots, and chuck voicers into them as needed for real-time control.</p>
<p class="p2"><br></p>
<p class="p5"><span class="s4">b = </span><span class="s2">MixingBoard</span><span class="s4">(</span><span class="s6">"demo"</span><span class="s4">);<span class="Apple-converted-space">  </span></span>// board with no mixers</p>
<p class="p4"><span class="s2">MixerChannelGUI</span>(mixer, b) =&gt; <span class="s2">MCG</span>.prNew(0);</p>
<p class="p9"><br></p>
<p class="p5">// assuming the voicer was created from a factory,</p>
<p class="p5">// this will assign the voicer's ~target to this GUI slot</p>
<p class="p4"><span class="s2">VC</span>(<span class="s3">\ghost</span>) =&gt; <span class="s2">MCG</span>(0);</p>
<p class="p2"><br></p>
<p class="p3">It's a little weird making a MixingBoard with empty MixerChannelGUIs, but it works and you only have to do it once. This code also assigns a MIDI controller to output level.</p>
<p class="p2"><br></p>
<p class="p4">~board = <span class="s2">MixingBoard</span>(<span class="s6">"chucking demo"</span>, <span class="s2">Library</span>.at(<span class="s3">\mixer</span>, <span class="s3">\smallskin</span>));</p>
<p class="p4">8.do({ <span class="s2">|i|</span> <span class="s2">MixerChannelGUI</span>(<span class="s2">nil</span>, ~board) =&gt; <span class="s2">MCG</span>.prNew(i);</p>
<p class="p5"><span class="s4"><span class="Apple-tab-span">	</span></span><span class="s2">MixerMIDIControl</span><span class="s4">(</span><span class="s3">\omni</span><span class="s4">, </span><span class="s2">nil</span><span class="s4">, </span><span class="s2">MCG</span><span class="s4">(i).v);<span class="Apple-tab-span">	</span></span>// skip this if you don't want the MIDI</p>
<p class="p4"><span class="Apple-tab-span">	</span>~board.add(<span class="s2">MCG</span>(i).v);</p>
<p class="p4">});</p>
<p class="p5"><span class="s4"><span class="Apple-tab-span">	</span></span>// insurance to make sure the board displays correctly</p>
<p class="p4"><span class="s2">AppClock</span>.sched(2, { ~board.refresh });</p>
<p class="p2"><b></b><br></p>
<p class="p3"><span class="s5"><b>MT(MixerChannelIndex)</b></span> -- MIDI Trigger -- automatic</p>
<p class="p2"><br></p>
<p class="p3">MIDI trigger provides a number of slots corresponding to keys on a MIDI keyboard. Each slot can hold a bound process. When receiving a MIDI note on, the slot toggles between three states:<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3"><i>Stopped</i>: idle (grey background in the GUI)<span class="Apple-converted-space"> </span></p>
<p class="p3"><i>Ready</i>: waiting to confirm the play/stop action (blue background)<span class="Apple-converted-space"> </span></p>
<p class="p3"><i>Playing</i>: process is running (green background)<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">The "ready" state is protection against accidental key triggers. To play or stop a process, you have to hit the MIDI key twice. If you hit the wrong key, you can simply omit the second keystroke. After a few seconds, ready state will end and the slot will go back to its previous state.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">Assign a process to a slot either programmatically, or dragging it into the GUI. Processes displayed in the GUI may be triggered by clicking on the slot. In this case, there is no ready state.</p>
<p class="p2"><br></p>
<p class="p5"><span class="s2">MT</span><span class="s4">(1).gui<span class="Apple-tab-span">	</span></span>// note, here you don't need .v</p>
<p class="p5"><span class="s2">BP</span><span class="s4">(</span><span class="s3">\someProcess</span><span class="s4">) =&gt; </span><span class="s2">MT</span><span class="s4">(1)<span class="Apple-tab-span">	</span></span>// assign to next midi note in line</p>
<p class="p5"><span class="s2">BP</span><span class="s4">(</span><span class="s3">\otherProcess</span><span class="s4">) =&gt;.72 </span><span class="s2">MT</span><span class="s4">(1)<span class="Apple-tab-span">	</span></span>// assign to midi note 72 (next will go in 73)</p>
<p class="p2"><b></b><br></p>
<p class="p8"><b>MIDI input management</b></p>
<p class="p2"><b></b><br></p>
<p class="p3"><span class="s5"><b>MBM(int)</b></span> -- MIDIBufManager -- prNew<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">Recording, storage and recall of note data from a MIDI device. This is a heavy object so you should not create more of them than you absolutely need.</p>
<p class="p2"><br></p>
<p class="p3">Short form for indexing MIDIRecBufs stored within:</p>
<p class="p3"><i>MBM(0)[0]</i></p>
<p class="p3"><i>MBM(0)[\name]</i>: outputs the first MIDIRecBuf named 'name' in the buf manager. If you have duplicate names, only the first one sharing the name can be retrieved this way.</p>
<p class="p2"><br></p>
<p class="p3"><span class="s5"><b>MRS(\name, mbm)</b></span> -- MIDIRecSocket<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">Not (strictly speaking) a chucking class. This is a place holder that announces your intent to record material either into a buffer manager or directly into a bound process.</p>
<p class="p2"><br></p>
<p class="p3">name -- the name of the finished buffer.</p>
<p class="p3">mbm -- an instance of MBM. Needed only when chucking directly into a bound process, in which case the buffer will be stored in that MBM.</p>
<p class="p2"><br></p>
<p class="p4"><span class="s2">MIDIBufManager</span>(chan:0) =&gt; <span class="s2">MBM</span>(0).prNew;</p>
<p class="p9"><br></p>
<p class="p5"><span class="s2">MRS</span><span class="s4">(</span><span class="s3">\melody</span><span class="s4">) =&gt; </span><span class="s2">MBM</span><span class="s4">(0);<span class="Apple-converted-space">  </span></span>// silently record and save the data</p>
<p class="p9"><br></p>
<p class="p5">// prepare for a live recording.<span class="Apple-converted-space"> </span></p>
<p class="p5">// The first note played on the keyboard will stop the current melody;</p>
<p class="p5">// when you stop recording, the new material will resume play automatically.</p>
<p class="p5">// THIS FEATURE IS NOT WORKING IN THIS RELEASE.</p>
<p class="p4"><span class="s2">MRS</span>(<span class="s3">\melody</span>, <span class="s2">MBM</span>(0)) =&gt;.mel <span class="s2">BP</span>(<span class="s3">\mel1</span>);</p>
<p class="p2"><br></p>
<p class="p8"><b>Process component management</b></p>
<p class="p2"><br></p>
<p class="p3">The following objects are used in the still-developing and unreleased AI sequencing framework. There are documented here it, but you may not have much use for them yet. But, you can use them for your own ends.</p>
<p class="p2"><br></p>
<p class="p3"><span class="s5"><b>MicRh(\symbol)</b></span> -- microrhythm -- automatic</p>
<p class="p3"><span class="s5"><b>MacRh(\symbol)</b></span> -- macrorhythm -- automatic</p>
<p class="p3"><span class="s5"><b>ArpegPat(\symbol)</b></span> -- arpeggiation pattern -- automatic<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">These classes accept either raw patterns, or functions that output patterns based on an argument (usually another pattern).<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">Microrhythm patterns must output arrays of 3 elements: [delta, length, gate]. Macrorhythm patterns must output two-element arrays: [delta, length].</p>
<p class="p2"><br></p>
<p class="p3">ArpegPat's should always take in an array of notes and return a pattern that plays those notes in some order (not necessarily the original order). You may change the notes array if needed (the caller will throw away the array).</p>
<p class="p2"><br></p>
<p class="p10"><span class="s4">#{ </span>|notes|<span class="s4"> </span>Pxrand<span class="s4">(notes, </span>inf<span class="s4">) } =&gt; </span>ArpegPat<span class="s4">(</span><span class="s3">\xrand</span><span class="s4">);</span></p>
<p class="p2"><br></p>
<p class="p3"><span class="s5"><b>Func(\symbol)</b></span> -- adaptation function -- automatic<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">Simplifies design of processes by providing a global repository of functions to manipulate note (or other) data.</p>
<p class="p2"><br></p>
<p class="p4">#{ <span class="s2">|notes|</span> notes.scramble } =&gt; <span class="s2">Func</span>(<span class="s3">\random</span>);</p>
<p class="p4"><span class="s2">Func</span>(<span class="s3">\random</span>).doAction([60, 62, 64, 65, 67]);<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">If there is no function for the given index, the original material will be returned.</p>
<p class="p2"><br></p>
<p class="p3">The adverb allowNil may be appended to =&gt; to override the normal behavior of Func, which is that the first input argument is returned if the function's result is nil.</p>
<p class="p2"><br></p>
<p class="p4">{ <span class="s2">|a, b|</span> (a &lt; b).if({ a + b }) } =&gt; <span class="s2">Func</span>(<span class="s3">\noNils</span>);</p>
<p class="p4">{ <span class="s2">|a, b|</span> (a &lt; b).if({ a + b }) } =&gt;.allowNil <span class="s2">Func</span>(<span class="s3">\nilsOK</span>);</p>
<p class="p9"><br></p>
<p class="p4"><span class="s2">Func</span>(<span class="s3">\noNils</span>).doAction(2, 5);</p>
<p class="p5"><span class="s2">Func</span><span class="s4">(</span><span class="s3">\noNils</span><span class="s4">).doAction(5, 2);<span class="Apple-tab-span">	</span></span>// result is 5, or 1st input argument</p>
<p class="p9"><br></p>
<p class="p4"><span class="s2">Func</span>(<span class="s3">\nilsOK</span>).doAction(5, 2);<span class="Apple-tab-span">	</span><span class="s7">// result is nil</span></p>
<p class="p2"><br></p>
<p class="p11"><b>ProtoEvent(\symbol)</b><span class="s8"> -- automatic<span class="Apple-converted-space"> </span></span></p>
<p class="p2"><br></p>
<p class="p3">Custom events gets stored in this class. Retrieve the event using ProtoEvent(\name).v.</p>
<p class="p2"><br></p>
<p class="p3">The event you pass in must have a function assigned to the <i>play</i> key. If you don't want the event to play anything per se, you can provide a dummy like 1 (which does nothing when .value'd).</p>
<p class="p2"><br></p>
<p class="p5"><span class="s4">(play: #{<span class="Apple-converted-space">  </span></span>/* do something in here */<span class="s4"> }) =&gt; </span><span class="s2">ProtoEvent</span><span class="s4">(</span><span class="s3">\uselessEvent</span><span class="s4">);</span></p>
<p class="p2"><br></p>
<p class="p3"><span class="s5"><b>Mode(\symbol)</b></span> -- automatic<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">Required for processes that work with modally-mapped data. Mode(\default) should always be populated, but you can override the default in specific processes.</p>
<p class="p2"><br></p>
<p class="p4"><span class="s2">ModalSpec</span>(#[0, 2, 3, 5, 7, 9, 10], 12, 2) =&gt; <span class="s2">Mode</span>(<span class="s3">\default</span>);<span class="Apple-converted-space">  </span><span class="s7">// D dorian<span class="Apple-converted-space"> </span></span></p>
<p class="p9"><br></p>
<p class="p3">A Mode object may contain an Array of ModalSpecs or Mode names. The adaptive melody and chord processes will assign the best fitting mode to each segment independently.</p>
<p class="p2"><br></p>
<p class="p6"><span class="s4">[</span>\cminor<span class="s4">, </span>\cmixolydian<span class="s4">] =&gt; </span><span class="s2">Mode</span><span class="s4">(</span>\cComposite<span class="s4">);</span></p>
<p class="p5">// or (I like this syntax better)</p>
<p class="p4">#[cminor, cmixolydian] =&gt; <span class="s2">Mode</span>(<span class="s3">\cComposite</span>);</p>
<p class="p2"><br></p>
<p class="p3">When using a Mode in a process, it's recommended to specify it by name only, e.g., \default rather than Mode(\default).v. The actual Mode will be refreshed whenever needed, allowing the Mode to be changed on the fly.</p>
<p class="p2"><br></p>
<p class="p3">The asMode method will return a Mode() object for the given Symbol, Mode() or nil. Note data should be converted using the mapMode and unmapMode methods.</p>
</body>
</html>
