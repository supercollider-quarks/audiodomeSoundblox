{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf290
{\fonttbl\f0\fnil\fcharset0 Monaco;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red0\green115\blue0;}
\deftab720
\pard\pardeftab720\ql\qnatural

\f0\fs18 \cf2 // jedem W\'fcrfel ist eine Geraeuschfamilie zugeordnet\cf0 \
\
\pard\pardeftab560\ql\qnatural
\cf0 \
(\
\pard\pardeftab560\ql\qnatural
\cf3 Server\cf0 .default = s = \cf3 Server\cf0 .internal;\
\
s.waitForBoot\{\
q = ();\
\
\cf2 // joseph\cf0 \
\cf2 // q.directory = "/Network/Servers/stitch/srv/nfs/volume1/home/till/samples/";\cf0 \
\
\cf2 // till\cf0 \
\cf2  q.directory = "/localvol/sound/share/audiosamples/koelnKalk/\cf4 sequencer/\cf2 ";\cf0 \
\
\cf2 // hubert\cf0 \
//q.directory = \cf4 "/Users/till/Documents/koelnKalk/sequencer/"\cf0 ;\
\
\cf2 /* open directory\
"open %".format(q.directory).unixCmd; // */\cf0 \
\
\
\
\cf2 // For each name given below, q.directory should have a directory containing files named 1-*.aiff, 2-*.aiff, etc. \cf0 \
\cf2 // If the files are n-channel, currently only the first channel is used.\cf0 \
\cf2 // be sure to have only .aiff files here. Neither wav, nor mp3 are supported yet. If you need to convert files easily, use e.g. Max ({\field{\*\fldinst{HYPERLINK "http://sbooth.org/Max/"}}{\fldrslt 
\f1\fs22 \cf2 http://sbooth.org/Max/}}), or sndfile-convert.\cf0 \
\
\cf2 // Link directory names to colors. Only given colores will be recognized, all other blocks are ignored.\cf0 \
q.colorToName = (\
	lightGreen: \cf4 \\sn\cf0 ,\
	red: \cf4 \\bass\cf0 , \
	blue: \cf4 \\chords\cf0 , \
	yellow: \cf4 \\hh\cf0 ,\
	orange: \cf4 \\synth\cf0 ,\
	green: \cf4 \\bd\cf0 \
);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\ql\qnatural\pardirnatural
\cf0 \
\pard\pardeftab560\ql\qnatural
\cf2 // the audiochannels to which the block speakers are attached to\cf0 \
q.blockChannels = (\
	yellow:		0,\
	lightGreen:	1,\
	blue:		2,\
	orange:		3,\
	red:			4,\
	green:		7\
);\
\
\
\
\cf2 /*q.blockChannels = (\
	yellow:		7,\
	lightGreen:	7,\
	blue:		7,\
	orange:		7,\
	red:			7,\
	green:		7\
);\
*/\cf0 \
\
q.visualsAddr = \cf3 NetAddr\cf0 (\cf4 "localhost"\cf0 , 12000);\
\
q.filenames = ();\
q.colorToName.keysValuesDo\{\cf3 |color, subdirname|\cf0 \
	q.filenames[color] = 6.collect\{\cf3 |i|\cf0 \
		\cf4 "%/%.aif"\cf0 .format(subdirname, i+1);\
	\}\
\};\
\
\cf2 /*\
q.filenames.printAll // */\cf0 \
\
\
\
q.buffers = q.filenames.collect\{\cf3 |blockfiles|\cf0 \
	blockfiles.collect\{\cf3 |name|\cf0 \
		\cf3 Buffer\cf0 .readChannel(s, q.directory ++ name, channels: [0], action:\{\cf4 "file % read.\\n"\cf0 .postf(name) \})\
\cf2 //		Buffer.read(s, q.directory ++ name, action:\{"file % read.\\n".postf(name) \})\cf0 \
	\}\
\};\
\
\cf2 // only first channel of the file is read \cf0 \
\
\cf2 /* test\
q.buffers.choose.choose.play \
\
q.sfile = SoundFile.openRead(q.directory ++ q.filenames[\\green][6]);\
\
q.sfile.numChannels\
q.sfile.close;\
\
\
// */\cf0 \
\
\}\
)\
\
\
(\
q.blocks = q.colorToName.collect\{\cf3 |v, color|\cf0  \cf3 BufferBlock\cf0 (color, 0, q.visualsAddr, q.buffers[color], q.blockChannels[color])\};\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\ql\qnatural\pardirnatural
\cf3 BufferBlock\cf0 .sendSynth;\
\pard\pardeftab560\ql\qnatural
\cf0 q.buffers.asArray.flatten.do\{\cf3 _\cf0 .normalize\};\
)\
\
(\
s.bind\{\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\ql\qnatural\pardirnatural
\cf3 BufferBlock\cf0 .startClock;\
\pard\pardeftab560\ql\qnatural
\cf0 q.blocks.do(\cf3 _\cf0 .play);\
\}\
)\
\
(\
s.bind\{\
q.blocks.do(\cf3 _\cf0 .stop);\
\}\
)\
\
\
q.blocks.do\{\cf3 |block|\cf0 \
	block.set(\cf5 \\amp\cf0 , 1);\
	\cf2 //block.out = 0\cf0 \
\};\
\
\
\pard\pardeftab560\ql\qnatural
\cf2 //////////////////////\cf0 \
\cf2 // Start SETO\cf0 \
\
(\
q.seto = \cf3 SETO_OSCTUIOServer\cf0 (\cf4 "2Dobj"\cf0 , \cf3 nil\cf0 , \cf3 JITseto\cf0 , \cf3 SETOIDistance\cf0 ); \
q.seto.start;\
\
\cf3 Tdef\cf0 (\cf5 \\player\cf0 , \{loop\{\
	0.03.wait;\
	\cf2 // bd\cf0 \
	q.blocks.green.setFace(126, \cf5 \\amps\cf0 , 1);q.blocks.green.setFace(126, \cf5 \\filterFreqs\cf0 , 260000);\
\
\
	q.blocks.blue.setFace(180, \cf5 \\amps\cf0 , 1);q.blocks.blue.setFace(180, \cf5 \\filterFreqs\cf0 , 260000);\
	q.blocks.red.setFace(108, \cf5 \\amps\cf0 , 1);q.blocks.red.setFace(108, \cf5 \\filterFreqs\cf0 , 260000);\
	q.blocks.lightGreen.setFace(144, \cf5 \\amps\cf0 , 1);q.blocks.lightGreen.setFace(144, \cf5 \\filterFreqs\cf0 , 260000);\
	q.blocks.orange.setFace(162, \cf5 \\amps\cf0 , 1);q.blocks.orange.setFace(162, \cf5 \\filterFreqs\cf0 , 260000);\
	q.blocks.yellow.setFace(198, \cf5 \\amps\cf0 , 1);q.blocks.yellow.setFace(198, \cf5 \\filterFreqs\cf0 , 260000);\
\}\}).play;\
\
\cf3 JITseto\cf0 .action = \{\cf3 |me|\cf0 \
	\cf3 var\cf0  block = q.blocks.detect\{\cf3 |block|\cf0  block.ids.includes(me.id)\};\
	block.notNil.if\{\
		\cf2 //block.color.postln;\cf0 \
		\cf2 //block.setFace(me.id, \\amps, ((sin(me.rotEuler.first) * 0.95).abs + 0.05));\cf0 \
		block.setFace(me.id, \cf5 \\amps\cf0 , me.pos.first.linlin(0, 1, 1, 1));\
		block.setFace(me.id, \cf5 \\filterFreqs\cf0 , sin(me.rotEuler.first*0.5).abs.linexp(0, 1, 1500, 260000));\
		\cf2 //block.setFace(me.id, \\amps, 0.9)\cf0 \
	\}\
\};\
\
\
\
\cf2 /*\
JITseto.action = nil; // */\cf0 \
\cf2 //JITseto.action = \{|me| me.postln\}; // */\cf0 \
)\
\
\
\cf2 ///////////////////////\cf0 \
\cf2 // Midi Mixer\cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab560\ql\qnatural\pardirnatural
\cf3 MIDIClient\cf0 .init;\
\cf3 MIDIIn\cf0 .connect;\
\
(\
\cf3 MIDIIn\cf0 .control = \{\cf3 |port, chan, ctlNum, val|\cf0  \
	[chan, ctlNum, val].postln;\
	\
	(ctlNum == 7).if\{ \cf2 // fader\cf0 \
		(chan == 8).if\{ \cf2 // master (right-most)\cf0 \
			q.blocks.do\{\cf3 |block|\cf0 \
				block.set(\cf5 \\masterAmp\cf0 , val.linlin(0, 127, 0, 1))	\
			\}\
		\};\
\
		(chan < 8).if\{ \cf2 // red (left-most)\cf0 \
			[chan, val].postln;\
			q.blocks[q.blockChannels.findKeyForValue(chan)].set(\cf5 \\amp\cf0 , val.linlin(0, 127, 0, 1))	\
		\};\
	\};\
	\
	(ctlNum == 17).if\{ \cf2 // lower button -> mute\cf0 \
		(chan == 8).if\{ \cf2 // master (right-most)\cf0 \
			q.blocks.do\{\cf3 |block|\cf0 \
				block.set(\cf5 \\masterMute\cf0 , val.linlin(0, 127, 0, 1))	\
			\}\
		\};\
\
		(chan < 8).if\{ \cf2 // red (1- rightmost)\cf0 \
			q.blocks[q.blockChannels.findKeyForValue(chan)].set(\cf5 \\mute\cf0 , val.linlin(0, 127, 0, 1))	\
		\};\
	\};\
	\
	(ctlNum == 10).if\{ \cf2 // knob\cf0 \
		(chan == 8).if\{ \cf2 // global rate -> master (right-most)\cf0 \
			\cf3 BufferBlock\cf0 .phase.set(\cf5 \\rate\cf0 , val.linlin(0, 127, 0.5, 2).round(0.01).postln)\
		\};\
		(chan == 3).if\{ \cf2 // global shift -> left to master\cf0 \
			q.blocks[\\orange].do\{\cf3 |block|\cf0 \
				block.set(\cf5 \\pitch\cf0 , val.linlin(0, 127, 0.5, 2).round(0.1).postln)	\
			\}\
		\};\
	\};\
\}\
\pard\pardeftab560\ql\qnatural
\cf0 )\
\
q.blocks.do\{\cf3 |block|\cf0 \
	block.synthParams.add(\cf5 \\masterMute\cf0  -> [0]);\
	block.synthParams.add(\cf5 \\mute\cf0  -> [0]);\
\}\
\
q.blocks[3].play\
q.blocks[3].out = 0\
\
q.blocks[3].stop\
\
\
\
\
\
\
\
q.blocks.do\{\cf3 |block|\cf0 \
	block.set(\cf5 \\amps\cf0 , 3);\
\}\
\
q.blocks.do\{\cf3 |block|\cf0 \
	block.stop;\
\}\
\
q.blocks[3].play\
q.blocks[3].out = 0\
q.blocks[3].stop\
\
q.blocks[1].set(side: 2, what: \cf5 \\rates\cf0 , val: 0.5);\
\
6.do\{\cf3 |i|\cf0 \
	q.blocks[1].set(side: i, what: \cf5 \\amps\cf0 , val: 0.5);\
\}\
\
6.do\{\cf3 |i|\cf0 \
	q.blocks[1].set(side: i, what: \cf5 \\rates\cf0 , val: rrand(0.5, 2.0));\
\}\
\
\
6.do\{\cf3 |i|\cf0 \
	q.blocks[0].set(side: i, what: \cf5 \\rates\cf0 , val: rrand(1, 4.0));\
\}\
\
\
\
x.setn(\cf5 \\amps\cf0 , [1, 0, 0, 0, 0, 0])\
x.setn(\cf5 \\amps\cf0 , [0, 0, 1, 0, 0, 0])\
x.setn(\cf5 \\amps\cf0 , 1!6)\
\
x.setn(\cf5 \\amps\cf0 , [10, 0, 0, 0, 0, 0, 0])\
\
\
x.setn(\cf5 \\amps\cf0 , [1, 1, 1, 1, 1, 1, 1])}